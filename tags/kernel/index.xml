<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Kernel on Low Level Pleasure</title>
    <link>https://repnz.github.io/tags/kernel/</link>
    <description>Recent content in Kernel on Low Level Pleasure</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 18 Jan 2020 01:30:37 +0200</lastBuildDate>
    
	<atom:link href="https://repnz.github.io/tags/kernel/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Dumping DPC Queues: Adventures in HIGH_LEVEL IRQL</title>
      <link>https://repnz.github.io/posts/practical-reverse-engineering/dumping-dpc-queues/</link>
      <pubDate>Sat, 18 Jan 2020 01:30:37 +0200</pubDate>
      
      <guid>https://repnz.github.io/posts/practical-reverse-engineering/dumping-dpc-queues/</guid>
      <description>This post is part of the Practical Reverse Engineering Exercises series.
To understand more about the basics of DPCs, read Reversing KeInsertQueueDpc
(Source code below.)
Exercise: Write a driver to enumerate all DPCs on the entire system. Make sure you support multi-processor systems! Explain the difficulties and how you solved them.
Sounds fun! let&amp;rsquo;s start. I thought about dividing this post to 2 posts, but nah
Doing Undocumented Shit in Windows First of all, we need to understand that accessing the DPC queue from a real product is an extremely bad idea because it&amp;rsquo;s a pretty undocumented data structure.</description>
    </item>
    
    <item>
      <title>Reversing DPC: KeInsertQueueDpc</title>
      <link>https://repnz.github.io/posts/practical-reverse-engineering/reversing-dpc-keinsertqueuedpc/</link>
      <pubDate>Sun, 05 Jan 2020 21:33:37 +0200</pubDate>
      
      <guid>https://repnz.github.io/posts/practical-reverse-engineering/reversing-dpc-keinsertqueuedpc/</guid>
      <description>Exercise:
Explain how the following functions work: KeInsertQueueDpc, KiRetireDpcList, KiExecuteDpc, and KiExecuteAllDpcs. If you feel like an overachiever, decompile those functions from the x86 and x64 assemblies and explain the differences.
If I want to explain the complete solution I&amp;rsquo;ll have to divide this exercise to 2 posts. The first post is pretty simple.. we are going to reverse engineer KeInsertQueueDpc. In future posts we&amp;rsquo;ll continue exploring DPC and we will write code that dumps the DPC queues.</description>
    </item>
    
    <item>
      <title>AuxKlibQueryModuleInformation</title>
      <link>https://repnz.github.io/posts/practical-reverse-engineering/query-module-information/</link>
      <pubDate>Fri, 27 Dec 2019 18:33:37 +0200</pubDate>
      
      <guid>https://repnz.github.io/posts/practical-reverse-engineering/query-module-information/</guid>
      <description>In this article I&amp;rsquo;m going over the solution to reverse engineering AuxKlibQueryModuleInformation. This exercise is one of the easiest exercises in the book.
Exercise:
In the walk-through, we mentioned that a driver can enumerate all loaded modules with the documented API AuxKlibQueryModuleInformation. Does this API guarantee that the returned module list is always up-to-date? Explain your answer. Next, reverse engineer AuxKlibQueryModuleInformation on Windows 8 and explain how it works. How does it handle the case when multiple threads are requesting access to the loaded module list?</description>
    </item>
    
    <item>
      <title>Practical Reverse Engineering Solutions</title>
      <link>https://repnz.github.io/posts/practical-reverse-engineering/solutions/</link>
      <pubDate>Fri, 27 Dec 2019 18:33:37 +0200</pubDate>
      
      <guid>https://repnz.github.io/posts/practical-reverse-engineering/solutions/</guid>
      <description>Hey, Here I save all the solutions to the windows kernel chapter of the practical reverse engineering book. The exercises in this book are pretty insightful.
The target audience of these posts are:
 People that want to read cool stuff about windows kernel reverse engineering People that want to learn how to break down reverse engineering tasks effeciently People that actually do the exercises and need a reference to the solutions.</description>
    </item>
    
    <item>
      <title>Abusing Signed Windows Drivers</title>
      <link>https://repnz.github.io/posts/abusing-signed-drivers/</link>
      <pubDate>Wed, 13 Nov 2019 01:23:57 +0200</pubDate>
      
      <guid>https://repnz.github.io/posts/abusing-signed-drivers/</guid>
      <description>The Problem We all know the &amp;ldquo;Driver Signature Enforcement&amp;rdquo; feature in windows. This security feature won&amp;rsquo;t allow you to load unsigned drivers into the windows kernel. To bypass this protection, many attackers use vulnerable signed drivers like turla. They try to find vulnerabilities in these drivers and exploit them. What people don&amp;rsquo;t think about is the fact that it&amp;rsquo;s way simpler than finding an exploitable memory corruption bug in a software driver - sometimes the driver just exposes the functionality via DeviceIoControl and this can be used to perform malicious operations in kernel mode.</description>
    </item>
    
    <item>
      <title>Autochk Rootkit Analysis</title>
      <link>https://repnz.github.io/posts/autochk-rootkit-analysis/</link>
      <pubDate>Fri, 01 Nov 2019 14:00:00 +0300</pubDate>
      
      <guid>https://repnz.github.io/posts/autochk-rootkit-analysis/</guid>
      <description>Introduction Finally had time to write about this rootkit I saw last week. This rootkit is a very simple, it does not employ any uber fancy methods or something, but I do find it nice so I wanted to share. The name of the driver is &amp;ldquo;autochk.sys&amp;rdquo; - that&amp;rsquo;s why we&amp;rsquo;ll call it the autochk rootkit. The sample is already known (28924b6329f5410a5cca30f3530a3fb8a97c23c9509a192f2092cbdf139a91d8), but I haven&amp;rsquo;t found any public analysis. The rootkit was compiled on the 27/8/2017 according to the PE timestamp.</description>
    </item>
    
    <item>
      <title>Random PDC Driver</title>
      <link>https://repnz.github.io/posts/random-pdc-driver/</link>
      <pubDate>Tue, 08 Oct 2019 16:37:09 +0300</pubDate>
      
      <guid>https://repnz.github.io/posts/random-pdc-driver/</guid>
      <description>Found this funny driver: The pdc.sys windows driver has a DriverUnload routine but it calls KeBugCheckEx causing a bluescreen.
Just run &amp;quot;sc stop pdc&amp;quot; and see for yourself ;)
I wonder why they registered DriverUnload if the driver does not support unload.. ðŸ¤” pic.twitter.com/TNpKIZGvZX
&amp;mdash; Ori Damari (@0xrepnz) October 8, 2019  </description>
    </item>
    
  </channel>
</rss>